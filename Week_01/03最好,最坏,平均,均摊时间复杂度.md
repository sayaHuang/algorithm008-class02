[TOC]

# 最好,最坏,平均,均摊时间复杂度

这段代码时间复杂度还是  O(n)吗?  
```C
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

## 最好的情况
最好的情况, 变量 x在数组第一位, 时间复杂度为O(1).  

## 最坏的情况
最坏的情况,变量 xr在数组最末位, 或不存在在数组中. 时间复杂度O(n).  

## 平均情况-- 加权平均时间复杂度
变量x `在数组中的概率` 和 `不在数组中的概率` 是相同的, 所以概率的值分别为1/2.  
变量x出现在 `0~n-1` 中任意位置的概率为 1/n, 所以根据`乘法法则` 要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)  
> 1 * 1/2n + 2 * 1/2n + 3 * 1/2n + ...... + n * 1/2n + n * 1/2 = (3n + 1) / 4

用大O表示法来表示, 时间复杂度任然为 O(n)  

## 均摊时间复杂度
均摊时间复杂度, 需要通过以下例子说明  
```C
 // array表示一个长度为n的数组
 // 代码中的array.length就等于n
 int[] array = new int[n];
 int count = 0;
 
 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }
```
### 计算平均时间复杂度
假设数组的长度为n, 需要分析俩种情况  
情况1: 数组没有装满, 此时的时间复杂度为O(1)  
情况2:数组装满了, 此时的时间复杂度为O(n)  

出现这n+1中的任意情况的概率都是相同的: 1/(n + 1)  
> 1 * 1/(n + 1) + 1 * 1/(n + 1) + 1 * 1/(n + 1) + ......+ 1 * 1/(n + 1) + n * 1/(n + 1) = 2n / (n + 1) 

用大O表示法来表示, 时间复杂度任然为 O(1)  
### 均摊时间复杂度
每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1).  

#### 什么时候适合使用 均摊时间复杂度
> 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。--  王争 数据结构与算法之美


#### Note:
我们没必要花太多精力去区分均摊时间复杂度和平均时间复杂度, 均摊时间复杂度就是一种特殊的平均时间复杂度  