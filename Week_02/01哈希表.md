[TOC]

# 哈希表

## 什么是 hash表
散列表(hash表/哈希表) 利用了数组随机访问下标的数据特性, 扩展而来. 
假设公司员工的工号从0开始, 一共有99个员工, 将员工档案保存到 Doucments[100]这个数组中, 想要查询88号员工的档案, 直接获取, Documents[88]即可. 实际上员工的工号跟数组下标正好对应上了,
`员工的工号和数组下标一一映射` , 这个就是 `散列思维` .   
只不过这个例子中 `散列函数` 为空  

### hash函数
假设 公司员工编号不是从0开始 , 而是WWW00, 此时可以通过   
```C
//伪代码
Int hash(employeeObject.code) { 
		return employeeObject.code.subString(range.lastTwo).toInt
}
```
插入: 散列函数 将元素的键值 映射为下标, 然后将数据存储到数组中对应的下标位置.   
查询: 使用键值查询数据的时候 , 使用同样的函数, 将键值转化为数组下标, 从数组中取出数据  
**Note:** 如果 hash 函数设计的太复杂了, 加大查询的时间, 会让数组随机访问下标失去优势, 所以  hash函数不适合设计的太复杂  

## 散列冲突
**hash函数设计的基本要求**  

1. 函数的计算结果应该是一个 非负整数
2. 如果 key1 == key2, 则hash(key1) == hash(key2)
3. 如果 key1 != key2, 则hash(key1) != hash(key2)
因为数组的空间是有限的, 现实中想要做到 `2` 和 `3` 同时满足, 这是不可能的! 这个时候就会发生 `散列冲突`, 如何解决散列冲突呢?  

### 开发寻址法
数组中保存的对象(或者结构体) 至少有这几个属性: `key`  `deleted` `value`
**线性探测-插入**: 如果key通过hash函数得出index  = 7, 但是出现了冲突, 我们就++index, 一个一个的往下查看, 知道找到第一个空闲的位置, 简单吧  
线性探测极端情况: 发生冲突, 就往下找,如果找到数组最后一个位置, 全占满了, 在从数组开头依次探查, 直到找到位置  
**线性探测-查询** key通过hash函数得出index  = 7, 这个时候比key和index=7的key, 是否相同, 不相同的话, 则按照线性的探测方法查找, 是否有相等的key, 如果找到空位还没有遇到相等的key则说明, 表中没有这个数  
**线性探测-删除** 删除的方法比较特殊, 由于查询的时候有几率线性的探索, 所以, 如果中途遇到了被删除的数据, 可能会以为查询的数据不存在, 其实数据的地址在该位置的后面, 所以无法直接删除数据, 合理的做法是标记为deleted. 遇到deleted继续向下查询, 相对的插入的时候, 遇到为空或者是deleted的数据均可插入  

**二次探测- 插入** ，跟线性探测很像，线性探测每次探测的步长是 1步, 二次探测, 每次走1^2^, 2^2^,3^2^...步  

### 双重散列
**插入** 使用一组散列函数, 先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置为止. 
**查询** 双重散列的查询也是同样的过程, 如果首次散列的index下的key值不等于取值的key, 再次散列  

### 链表法
相比 开房寻址法, 链表法的使用频率更高, hash表将散列函数返回值相同的 数据, 存储到同一个链表中   
**插入:**通过散列函数的返回值确认数组下标, 并保存到对应的链表中,O(1)  
**删除**: 通过散列函数找到对应链表, 在遍历链表, 通过key值比对找到对应的结点, 删除元素  
**查询**: 通过散列函数找到对应链表, 在遍历表中结点, 通过key值比确认是否有相同的key, 直到链表结尾, 则说明表中没有该数据  

### 如何选择冲突解决办法
实际上 `开发寻址法` 和 `链表法` 都非常的实用, LinkedHashMap采用了`链表法` , ThreadLocalMap 采用了 `开发寻址法`  

#### `开发寻址法`优劣
**优:**
1. 可以高效的利用CPU的缓存加快查询速度
2. 序列化比较简单
**劣** 
由于数据都存储在数组中, 所以散列冲突的几率很高, 为了高插入的效率,  `载荷因子` 不易设置的太大, 最后的结果是占用更多的空间  
**总结:** 如果数据量比较小, 就适合采用开发寻址法

#### `链表法`优劣
**优:** 
1. 对内存的利用率比开发寻址法要高
2. 链表法下,  哈希表的 `载荷因子` 即使大于1, 也不会让性能下降很多
3. 即使 `载荷因子` 太大(eg =10),散列冲突导致链表太长, 也可以将链表改造成 跳表, 红黑树, 这样查询, 删除, 和插入的效率也可以维持在O(logN)
**劣** 
1. 天然的链表是不连续的内存, 所以CPU缓存无法发挥最大的性能
**总结:** 如果需要存储的数据量比较大, 就适合链表法

## 散列表扩容
随着数据的增加, 散列表势必需要扩容, 远古程序媛规定了 `载荷因子` 用于判断是否扩容   
载荷因子 = 填入表中元素的个数(count) / 散列表长度(length)  
不难看出是一个Float类型数, 当载荷因子越大哈希冲突越多，不命中率越高。CPU缓存会大大升高.   

**所以好的散列表, 需要根据使用实际情况, 设置合理的 `载荷因子`**
1. 如果内存空间不紧张, 对执行效率要求很高可以, 将载荷因子的值调小
2. 如果内存空间紧张, 对执行效率要求不高, 可以调高值, 设置大于1

### 如何避免低效的扩容
散列的数组容量扩大为原来的俩倍, 由于数组容量变大了, 所以需要将key重新计算匹配散列到数组中. 所以如果代码是直接服务于用户的, 这个时候, 一次性扩容消耗的等待时间是很伤用户体验的
**解决办法**: 
1. 当载荷因子越过阀值之后, 只是申请新的空间, 不搬移数据
2. 每次做新数据插入的时候, 分批搬移部分数据到新数组中. 
3. 数据查询的时候, 就需要查询俩张表


## 总结
散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。散列表两个核心问题是`散列函数设计`和`散列冲突解决`。散列冲突有两种常用的解决方法，开放寻址法和链表法。`散列函数设计的好坏`和`散列载荷因子的数值设置的合理`决定了散列冲突的概率，`散列冲突的概率`和`散列冲突的合理解决` 也就决定散列表的性能。

## 参看链接

[王争-数据与算法之美](https://time.geekbang.org/column/article/64586)









