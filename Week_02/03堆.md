[TOC]

# 堆

## 什么是堆
堆是是一种特殊的树  
1. 堆是一棵完全二叉树
2. 堆的每一个节点的值都必须大于等于(或者小于等于) 其子树中每个节点的值. 也可以理解为每个节点的值必须大于等于(或者小于等于)其左右子节点的值. 

**大顶堆:** 节点的值 大于等于 其左右子节点的值  
**小顶堆:** 节点的值 小于等于 其左右子节点的值  

## 如何实现一个堆
之前说过`完全二叉树`, 适合存储在数组中, 所以`堆`也存储在`数组`中. 下面的例子都是大顶堆. 

### 插入
从下往上 `堆化` : 新插入的元素放在数组最末位, 和父节点对比大小, 如果比父节点大, 交换,如此迭代, 直到找到比他大的节点, 跳出迭代
```java
public class Heap {
  private int[] a; // 数组，从下标1开始存储数据
  private int n;  // 堆可以存储的最大数据个数
  private int count; // 堆中已经存储的数据个数

  public Heap(int capacity) {
    a = new int[capacity + 1];
    n = capacity;
    count = 0;
  }

  public void insert(int data) {
    if (count >= n) return; // 堆满了
    ++count;
    a[count] = data;
    int i = count;
    while (i/2 > 0 && a[i] > a[i/2]) { // 自下往上堆化
      swap(a, i, i/2); // swap()函数作用：交换下标为i和i/2的两个元素
      i = i/2;
    }
  }
 }
```
时间复杂度: O(logN) 和树的高度成正比  


### 删除堆顶元素
从上往下`堆化`: 将数组最末的元素放到堆顶, 在同左右节点对比, 如果比俩个子节点都小, 则同较小的子节点交换, 如此重复, 直到找到一个位置比俩个儿子都大, 或者到叶子节点
```java

public void removeMax() {
  if (count == 0) return -1; // 堆中没有数据
  a[1] = a[count];
  --count;
  heapify(a, count, 1);
}
//n 为堆的元素个数
//i 为待堆化的元素下标
private void heapify(int[] a, int n, int i) { // 自上往下堆化
  while (true) {
    int maxPos = i;
    if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
    if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
    if (maxPos == i) break;
    swap(a, i, maxPos);
    i = maxPos;
  }
}
```
时间复杂度: O(logN) 和树的高度成正比  

## 堆排序
### 建堆
从上往下排序, 并且叶子节点没有可以比较的子节点, 可以直接跳过, 从 N / 2开始从上往下堆化. 直到位置1
```java
private static void buildHeap(int[] a, int n) {
  for (int i = n/2; i >= 1; --i) {
    heapify(a, n, i);
  }
}

private static void heapify(int[] a, int n, int i) {
  while (true) {
    int maxPos = i;
    if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
    if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
    if (maxPos == i) break;
    swap(a, i, maxPos);
    i = maxPos;
  }
}
```
时间复杂度看似是O(logN), 但是实际上是O(N)

### 排序
进行N次 `删除堆顶元素`, 将堆顶元素同最末尾元素交换, 之后在堆化
```java
// n表示数据的个数，数组a中的数据从下标1到n的位置。
public static void sort(int[] a, int n) {
  buildHeap(a, n);
  int k = n;
  while (k > 1) {
    swap(a, 1, k);
    --k;
    heapify(a, k, 1);
  }
}
```
时间复杂度, 一个元素排到为需要O(logN), N个元素是O(N*logN)

### 堆排序时间复杂度
1. O(N) + O(N*logN) , 
2. 堆排序是原地算法
3. 但是不是稳定的排序算法, 因为在堆化的时候, 使用类似删除元素的操作, 交换元素会打乱顺序

## 堆排序 VS 快排
堆排序劣势: 
1. 堆排序, 需要大量的堆化, 多半是i*2, i*2+1,的方式访问下标, 对CPU不友好, 快排一般是i++的访问下标, 所以对CPU更友好
2. 堆排序, 数据交换的次数, 比快速排序要多

## 堆应用
### 优先级队列
用堆来实现一个优先级队列是最高效的, 因为堆的定义保证了, 极值在堆顶, 这非常符合 优先队列中优先级高的, 最先出队的要求. 从优先级中取出最高级的元素, 就相当于取出堆顶元素.   
**优先队列应用算法: ** 赫夫曼编码. 图的最短路径 , 生成最小树  
**优先级队列的实现: ** java- PriorityQueue   C++ priority_queue  

### 合并有序小文件
合并100个内容有序的小文件为一个大文件,  每个小文件大小100MB. 
**思路: ** 从100个文件中各取第一个字符串放到 小顶堆, 堆化完成之后,假设堆顶元素来自于13.txt, 将堆顶元素从队列中取出, 并放入大文件中, 在从13.txt文件取出下一个元素, 插入堆中, 直到都为空 为止  

[leetcode-合并k个有序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/) 

### 搞定定时器
假设有一个定时器的任务列表, 比起1秒都扫描一次确认是否有待执行的任务, 可以使用小顶堆, 按照定时任务的时间, 堆化完成之后, 取堆顶的元素同当前时间对比, 得出时间T, T秒之后执行任务即可, 如此往复, 直到没有任务为止  

### TOP K问题
#### 静态TOP K问题
维护一个大小为K的小顶堆 , 将保存在数组中的元素依次和top元素比较, 比top小则不做处理, 比top大, 则删除堆顶元素, 插入数组中的元素到堆顶, 在堆化, 如此重复, 直到数组中最后一个元素.    
时间复杂度: O(N*logN)  

#### 动态TOP K问题
动态的数据, 就是先就某一时刻的数组取出大小为k的小顶堆, 数据插入时,  将插入的数据同top对比, 小的话不做处理, 打的话, 删除堆顶数据, 在堆化  

### 利用堆求中位数
#### 静态数据中位数
对于静态的数据, 中位数字固定, 排序之后, 就可以直接去中值  

#### 动态数据中位数
对于动态的数据, 中位数据时刻在变, 就不适合每次都排序再返回了.  
初始化的时候, 将排好序的数据, 从中间一份为二, 前段数据形成大顶堆, 中位数字在堆顶, 后段数据形成小顶堆, 中位数字在堆顶.   
**数据总数为-`偶数`:**大顶堆存储 N/2 数据量 , 小顶堆存储 N/2 数据量  
**数据总数为-`奇数`:**大顶堆存储 N/2+1 数据量 , 小顶堆存储 N/2 数据量  
**中位数一般从 大顶堆 堆顶取** O(1)   

**插入数据** 新数据如果小于等于大顶堆元素, 则放入大顶堆, 反之放入小顶堆.  每次插入如数据之后`维护`俩个堆数据的量, `维护的准则`同初始的时候相同. `方法`是将数据量多的一组的`堆顶`元素,放入到另一个堆`堆顶`,O(logN) 

#### 如何快速求接口的 99% 响应时间
**99% 的响应时间**, 意思就是将100个接口的响应时间的数据,按照响应的时间从小到大排序, 在第99位的数据, 就是99%的响应时间.   
**思路:**类似求中位数的思路, 维护俩个堆, 大顶堆保存前99%的数据, 小顶堆保存1%的数据,
**取值: **也是从大顶堆取值, O(1)  
**插入数据**也雷同, 新数据同大顶堆数据对比, 小于等于则放入大顶堆, 反之放入小顶堆, 每次插入也需要维护俩个堆的数据比例为 99:1,O(logN)  

### TOP10 热门搜索关键词
**题目:** 有一个文件包含10亿搜索关键词的日志文件, 如何快速获取TOP 10 最热门的搜素关键词  
**前提:** 处理硬件为单机, 可以使用的内存为1GB   
**解答:**  
1. 使用支持快速查找, 插入的数据结构,统计数据相同搜索关键词出现的次数, 例如: 散列表, 平衡二叉查找树. 
2. 假设使用的是散列表, key为关键词, value为出现次数, 通过遍历10Y数据, 完成搜索关键词次数的存储之后
3. 然后建立一个大小为10的小顶堆, 然后在遍历散列表, 每次同堆顶元素对比, 大于堆顶元素则放入堆中, 遍历完毕之后得出结果. 
**上述方法的漏洞:**  
10Y关键词, 假设每个关键词平均出现10次, 每个关键词的长度为50个字节, 那么存储这些关键词的空间起码是5GB, 这还不加上解决散列冲突的空间损耗, (链表损耗小于数组), 所以单机的内存无法一次性存储所有数据  
**解决漏洞-- 分治思想:**  
1. 通过哈希算法将10Y数据分配到00~09的文件中, 假如通过md5算法得出对应hash值, 在同/10取值,放入对应的文件中
2. 这样每个小文件中的搜索关键词的数量, 就完全可以放到内存中了
3. 每个文件求TOP10, 在从10个TOP10中取 TOP10

## 参考网址
[王争 -- 算法于数据之美](https://time.geekbang.org/column/article/68334)