[TOC]

# 学习笔记

## 什么是 hash表
散列表(hash表/哈希表) 利用了数组随机访问下标的数据特性, 扩展而来. 
假设公司员工的工号从0开始, 一共有99个员工, 将员工档案保存到 Doucments[100]这个数组中, 想要查询88号员工的档案, 直接获取, Documents[88]即可. 实际上员工的工号跟数组下标正好对应上了,
`员工的工号和数组下标一一映射` , 这个就是 `散列思维` .   
只不过这个例子中 `散列函数` 为空  

### hash函数
假设 公司员工编号不是从0开始 , 而是WWW00, 此时可以通过   
```C
//伪代码
Int hash(employeeObject.code) { 
		return employeeObject.code.subString(range.lastTwo).toInt
}
```
赋值: 散列函数 将元素的键值 映射为下标, 然后将数据存储到数组中对应的下标位置.   
查询: 使用键值查询数据的时候 , 使用同样的函数, 将键值转化为数组下标, 从数组中取出数据  
**Note:** 如果 hash 函数设计的太复杂了, 加大查询的时间, 会让数组随机访问下标失去优势, 所以  hash函数不适合设计的太复杂  

[更多](./01哈希表.md)

## 什么是树
森林里面的树, 和数据结构里面的树, 样子很像, 有组干和枝杈. 

```swift
    3        root 根节点
   / \
  9  20      20 相对于 15/7为父节点, 相对于3 为子节点, 相对于 9 为兄弟节点
    /  \
   15   7    9 相对于 7(或15) 为叔叔节点
             9 / 15 / 7 均为子节点
```
`高度`, 从叶子结点按0开始计算, 往上数依次+1  
`深度`, 从根结点按0开始计算, 往下数依次+1   
`层` , 从根结点按1开始计算, 往下数依次+1   

### 特殊的树
`二叉树`的每个节点最多有两个子节点，分别是左子节点和右子节点  
`完全二叉树`: 叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大
`满二叉树` (特殊的完全二叉树) :  叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点  

## 树的存储
**数组:** 数组适合存储, 完全二叉树  
```swift
     17        
   /    \
  9     20     
 / \   /  \
6  10 15   27    
```
array[1] = 17,  
array[2] = 9, array[3] = 20,  
array[4] = 6, array[5] = 10,array[6] = 15, array[7] = 27  
```
假设  index = 2
     左子节点 = index * 2
     右子节点 = index * 2 + 1
     父结点 = index / 2
```
从上面的例子不难看出 为什么数组适合保存 完全二叉树了吧, 也可以理解为什么 完全二叉树的最底层叶子结点需要靠左了吧, 这样存储的时候可以少浪费一些数组空间  

**链表:** 合适存储树, 但是无法完全发挥CPU的缓存效率, 多次插入,删除,造成内存空间碎片化, 所以完全二叉树推荐数组存储  

## 遍历函数
前中后, 标识着 root 什么时候输出
```C++
void preOrder(Node* root) {
  if (root == null) return;
  println(root); 
  preOrder(root->left);
  preOrder(root->right);
}

void inOrder(Node* root) {
  if (root == null) return;
  println(root); 
  print root // 此处为伪代码，表示打印root节点
  inOrder(root->right);
}

void postOrder(Node* root) {
  if (root == null) return;
  postOrder(root->left);
  postOrder(root->right);
  println(root); 
}
```
时间复杂度: O(N)
空间复杂度: O(N)
