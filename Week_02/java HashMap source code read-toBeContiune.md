[TOC]

# java HashMap source code read
分析一个hash表的时候, 可以从插入想起, 插入数据需要经过 `散列函数` , 插入数据可能出现 `散列冲突`,  `装载因子`的值的大小也决定了冲突发生的频率, 如何解决冲突合理设置装载因子  

1. 初始大小  
HashMap默认初始值是16, 在初始化HashMap的时候是可以设置初始值的, 如果可以提前初始值, 可以减少扩容的次数, 提高性能  
2. 散列函数  
散列函数不复杂, 将key均匀分布即可
```java
int hash(Object key) {
    int h = key.hashCode()；
    return (h ^ (h >>> 16)) & (capicity -1); //capicity表示散列表的大小
}
```
3. 装载因子  
默认的 `装载因子` 是0.75, 当元素中的值越过阀值, 就会将容量扩大为原来的倆倍  
4. 链表法解决散列冲突  
一单链表太长也会影响 表的性能, 所以当长度超过`8` 的时候, 则将链表转换为红黑数, 在数据插入和删除的动态过程中, 如果链表的长度又少于8个, 就在转化为链表,  红黑数也需要维护平衡, 结点数量少的情况下, 红黑数对性能没有太大的提高

代码摘要
```java
//put
//get
```

## 如何设计一个工业级别的散列表
工业级别的散列函数需要满足的要求
1.  支持快速的查询, 删除, 插入
2.  对内存的消耗合理
3.  在极端的情况下散列表的性能也不会退化的太多
解决办法: 
1. 根据待处理的数据, 设计计算不耗时间, 可以将key均匀分布的 散列函数
2. 根据硬件条件和效率的对执行效率的要求, 设置 载荷因子
3. 选择适合的 散列冲突的解决办法