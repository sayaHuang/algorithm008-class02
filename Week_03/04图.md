[TOC]
# 图
## 什么是图
相比于树, 图同样也是二维数据结构, 只不过图中的点可以和任意个其他的点链接, 是一种多对多的关系  
**顶点** 树种的每个点叫结点, 图中的每个点是顶点  
**边** 俩个顶点相连形成边  
**度** 跟顶点相连接的边的个数  

既然有边那就涉及到有方向的边和没有方向的边, 对应的就是 **有向图** 和 **无向图**  
**出度** 就某个顶点来说, 有多少条边指出去  
**入读** 就某个顶点来说, 有多少条边指向他  

**例子**  
就`微博`来说, 微博这个圈子有多少用户就有多少`顶点`, A用户关注了B用户, 则形成一条A指向B的边, 对于A用户来说, 增加了一个 `出度` , 对于B用户来说增加了一个`入度`   
`微信`用户则不存在`出度`和`入读`的问题, 只要加了好友就是相互的, 所以只要加了好友, 就会在A B用户之间形成`边`  
`QQ`就A B好友之间不仅右边, 还会根据联系的频繁程度, 有一个相互的亲密度, 这设计到一个新的概念 `带权图` , 在QQ的例子中, 每个边上的权重, 标识 好友之间的亲密度  

## 存储方法
### 邻接矩阵
邻接矩阵的存储方式, 依赖于一个二维数组, 如果A B俩个顶点相连, 则设置M[a][b] 和 M[b][a] 为1, 如果是带权图, 则设置权重  
**劣势**  
1. 所以不难看出, 邻接矩阵的存储方法会浪费一半的空间
2. 假设微博有好几亿用户, 对应的二维矩阵的长度就是好几亿,但是每个用户的好友个数为个位数字, 所以就更加的浪费空间  
**优势**  
1. 二维数组访问的速度还是很快的, 因为是数组吗
2. 可以将很多图的运算转换成矩阵之间的运算
**总结**  
1. 数据量比较小的时候, 适合用邻接矩阵的存储  

### 邻接列表
#### 无向图的邻接列表
长的很像 散列表, 数组中的每个元素是`顶点`, 每个数组元素有一个属性 next, 类型也是顶点, 并且使用链表的形式保存该元素的`边`, 
**优化** 如果遇到大V的话链表就会太长导致查询过慢, 所以可以考虑使用 红黑树 或者 跳表优化链表, 将时间复杂度从O(N), 降到O(NlogN)  

#### 有向图的邻接列表
就微博的例子来说 , 需求1查询粉丝列表,分页返回 需求2 查询关注列表, 分页返回
**领接表** 中保存A用户关注的用户
**逆领接表** 中保存关注了 A的用户
**优化** 
* 因为需要分页返回粉丝列表, 选择跳表最合适, 因为跳表本身就是有序的
* 红黑树还需要中序遍历
* 散列表本身没有顺序, 需要排序
* 有序动态数组的维护有序的成本太高
* 所以跳表最合适

**微博的用户量级为几亿** 所以无法保存到内存中, 我们可以通过哈希算法将数据分片, 在分别存储在不同的机器上, 当我们查询用户关系的时候可以使用相同的hash算法定位到存储的机器, 即可
**当然还可以使用外部存储的方式**

## 参考链接

[递归 -- 数据结构与算法之美](https://time.geekbang.org/column/article/70537)