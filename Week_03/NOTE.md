[TOC]

# 学习笔记
## 每日一题
### 239-滑动窗口最大值
这道题目考察对 堆 的使用, java的解决办法可以使用内置的优先队列, 当然也可以使用 双端队列
遍历数组:   
1. index >= k的时候需要注意, 最大值是否被移出
2. 有新的数据加入的时候, 确保堆顶 或者 双端队列的first是最大值
3. 在数据 index >= k-1的时候就可以从堆中或者双端队列的first取值了
[每日一题-239-滑动窗口最大值.md](./每日一题-239-滑动窗口最大值.md)

## M68-二叉树的最近公共父节点
1. 处理二叉树
2. 寻找俩个节点的最近(深度最深)相同的父节点
3. 树中所有节点的值是唯一的
4. p、q 为不同节点且均存在于给定的二叉树中
5. p 或 q本身可以成为最近父节点
这就标识肯定有结果, 使用递归的方式遍历树, 遇到p,q则返回p,q, 不在深入下去, 接着处理一下递归的结果, 如果左右都不为空, 则找到了父节点.  
[每日一题-M68-二叉树的最近公共父节点.md](./每日一题-M68-二叉树的最近公共父节点.md)

## 297- 二叉树的序列化与反序列化
1. 序列化的时候, 使用前序的方式遍历链表, 并且保存到字符串中.  
2. 已","号分割, 已"X"衔接再叶子节点尾部, 标识叶子节点  
3. 反序列化的时候, 将字符串转换为数组, 从数组首部取数据, 第一个就是根节点, 这个时候, 就体现出来了前序遍历的好处了
4. 接着按照前序的方式, 反序列化二叉树
[每日一题-297-二叉树的序列化与反序列化.md](./每日一题-297-二叉树的序列化与反序列化.md)

## 200- 岛屿数量
这道题可以使用 递归的方式, 也可以使用 迭代的方式完成. 递归的话使用的是系统的栈, dfs的方式将1 标记为 0, 迭代的话使用while循环+queue完成标记.
[每日一题-200-岛屿数量.md](./每日一题-200-岛屿数量.md)

## 递归

## Sqrt(x):牛顿迭代法和Quake-III中的神奇方法
```C
int mysqrt(int x){
	double tmpx = x;
	double k = 1.0;
	double k0 = 0.0;
	while(abs(k0-k) >= 1){
		k0 = k;
		k = (k + tmpx/k)/2;
	}
	return (int)k;
}
```

下面再贴一下Quake-III中的神奇解法
```C
int mysqrt(int x){
	float tmpx = (float)x;
	float xhalf = 0.5f*tmpx;
	int i = *(int*)&tmpx;
	i = 0x5f375a86 - (i >> 1);
	tmpx = *(float*) & i;
	tmpx = tmpx * (1.5f - xhalf*tmpx*tmpx);
	tmpx = tmpx * (1.5f - xhalf*tmpx*tmpx);


	int res = (int)(1.0/tmpx);
	if((res+1) * (res + 1) <= x)
		res += 1;
	return res;
}
```

[牛顿迭代法快速寻找平方根](http://www.matrix67.com/blog/archives/361)