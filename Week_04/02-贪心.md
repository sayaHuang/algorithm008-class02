[TOC]

# 贪心

## 什么是贪心
**题目:** 如果背包可以容纳 50kg, 可以装各种豆子, 每个豆子的总量和总价值各不同, 期望背包所装的物品总价值最大.   
黑豆 总重量 20kg, 总价格 80元  
红豆 总重量 60kg, 总价格 1200元  
**答** 所以为了总价值最大, 先放单价最大的
**分析** 典型的贪心思想, 在每一次选择的时候, 选当前可选中最好的一项,最终的结果就是全局最优, 不能回溯  

## 贪心思想分析
1. 针对一组数据, 有`限制值`和`期望值`, 在满足限制的情况下, 期望值最大. 限制在50kg的装载范围内, 总价值最大
2. 贪心算法 并不总能给出最优解 
 *  找零问题, 硬币面值为100,99,1, 仅数量每种各100张, 需要找零396元, 期望使用的硬币最少
 *  贪心算法先用100, 在用99, 在用1, 最后得 使用3张100元, 96个1元
 *  其实最优解是使用4个99元
 *  贪心思想是每一次选择, 都选择最优的, 但是之前的选择会限制后面的选择, 从而无法达到全局最优
 *  类似人生路口的各种选项, 每次都做出当前情况的最优, 但是不一定可以达到最优的人生, 人生最优的评价标准又是什么呢, 是社会公认的价值观, 但是到达了之后, 又真的是最优的么
3. 什么样的问题适合贪心思想
 * 每次选择最优的解, 对期望值贡献也是最大的
 * 找零问题, 面值为 100 10 1, 仅数量每种各100张, 需要找零396元, 期望使用的硬币最少
 * 贪心算法先用100, 在用10, 在用1, 最后得 使用3张100元, 9个10元, 6个1元
 * 不难发现这个就是最优解, 因为选择 10个10元 , 就是选1个100元

## 贪心算法实战分析
### 区间覆盖
**问题** 假设有n个区间
```C
区间: [6,8],[2,4],[3,5],[1,5],[5,9],[8,10]
```
从这n个区间中选出一部分, 要求区间不相交, 期望选出最多的区间

**思路**
1. 从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中结束最早的（end 最小）。
2. 把所有与 x 区间相交的区间从区间集合 intvs 中删除。
3. 重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。

```swift
func eraseOverlapIntervals(_ intervals: [[Int]]) -> [[Int]] {
    if intervals.count < 1 { return [[Int]]() }
    let intls = intervals.sorted { (first, second) -> Bool in
        return first[1] < second[1]
    }
    var result = [intls[0]];
    var curSmallEnd = intls[0][1]
    var index = 1;
    while index < intls.count {
        if intls[index][0] >= curSmallEnd {
            curSmallEnd = intls[index][1]
            result.append(intls[index])
        }
        index += 1
    }
    return result;
}
```

## 参考链接
[递归 -- 数据结构与算法之美](https://time.geekbang.org/column/article/73188)