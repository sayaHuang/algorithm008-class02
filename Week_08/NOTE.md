[TOC]

# 学习笔记

## 每日一题
### 每日一题-191-位1的个数
**汉明距离: ** 两个等长字符串之间的汉明距离是两个字符串对应位置的不同字符的个数。换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数  
**计算汉明距离: ** 对两个字符串进行异或运算，并统计结果为1的个数，那么这个数就是汉明距离  
**汉明重量: ** 一串符号中非零符号的个数。因此它等同于同样长度的全零符号串的汉明距离.   
**计算汉明重量: **   
**方法一:**  
1. 计算出来的值i的二进制可以按每2个二进制位为一组进行分组，各组的十进制表示的就是该组的汉明重量。
2. 计算出来的值i的二进制可以按每4个二进制位为一组进行分组，各组的十进制表示的就是该组的汉明重量。
3. 计算出来的值i的二进制可以按每8个二进制位为一组进行分组，各组的十进制表示的就是该组的汉明重量。
4. i * (0x01010101)计算出汉明重量并记录在二进制的高八位，>>24语句则通过右移运算，将汉明重量移到最低八位，最后二进制对应的十进制数就是汉明重量。
```C
// 计算32位二进制的汉明重量
int32_t swar(int32_t i)
{    
    i = (i & 0x55555555) + ((i >> 1) & 0x55555555); //binary: 01010101
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333); //binary: 00110011
    i = (i & 0x0F0F0F0F) + ((i >> 4) & 0x0F0F0F0F); //binary: 00001111
    i = (i * (0x01010101) >> 24);
    return i;
}
```
时间复杂度 - O(1)  

**方法二: **
如果已知大多数数据位是0的话，那么还有更快的算法  
```C
//This is better when most bits in x are 0
//It uses 3 arithmetic operations and one comparison/branch per "1" bit in x.
int popcount_4(uint64 x) {
    uint64 count;
    for (count=0; x; count++)
  		  //n的最后一位1, 在n-1之后会变为0
        //n->20-> 10100   n-1->19-> 10011
        x &= x-1;
    return count;
}
```
[汉明重量](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F)  
[汉明距离](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB)  

## 位运算

