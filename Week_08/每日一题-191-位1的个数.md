[TOC]

# 每日一题-位1的个数

## 题目
编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。  
**示例3:**  
```java
输入：11111111111111111111111111111101   (-3)
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

**提示:**
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。  

### 读题所得
1. 不需要管第一位是否是符号位

## 方法一: 
已知大多数数据位是0的话，那么还有更快的算法  
```java
    public int hammingWeight2(int n) {
        //不需要处理第一位是否是符号位
        int count = 0;
        //n的最后一位1, 在n-1之后会变为0
        //n->20-> 10100   n-1->19-> 10011
        for (count = 0; n != 0 ; ++count) {
            n &= n-1;
        }
        return count;
    }
```
### 复杂度
* 时间复杂度: O(1)
* 空间复杂度: O(1)

## 方法二: 
```java
    public static int hammingWeight1(int n) {
	int ones = 0;
    	while(n!=0) {
    		ones += (n & 1);
    		n = n>>>1;
    	}
    	return ones;
    }
```
### 复杂度
* 时间复杂度: O(1)
* 空间复杂度: O(1)

## 方法三:
1. 计算出来的值i的二进制可以按每2个二进制位为一组进行分组，各组的十进制表示的就是该组的汉明重量。
2. 计算出来的值i的二进制可以按每4个二进制位为一组进行分组，各组的十进制表示的就是该组的汉明重量。
3. 计算出来的值i的二进制可以按每8个二进制位为一组进行分组，各组的十进制表示的就是该组的汉明重量。
4. i * (0x01010101)计算出汉明重量并记录在二进制的高八位，>>24语句则通过右移运算，将汉明重量移到最低八位，最后二进制对应的十进制数就是汉明重量。
```java
    public static int hammingWeight(int i) {
        i = (i & 0x55555555) + ((i >> 1) & 0x55555555); //binary: 01010101
        i = (i & 0x33333333) + ((i >> 2) & 0x33333333); //binary: 00110011
        i = (i & 0x0F0F0F0F) + ((i >> 4) & 0x0F0F0F0F); //binary: 00001111
        i = (i * (0x01010101) >> 24);
        return i;
    }
```
### 复杂度
* 时间复杂度: O(1)
* 空间复杂度: O(1)

## 测试用例
00000000000000000000000000001011  

## leetcode链接
[leetcode链接题目链接](https://leetcode-cn.com/problems/number-of-1-bits)  